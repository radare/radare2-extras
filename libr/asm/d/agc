com=complement the `A` register (address 0)
ddoubl=add the A, `L` register pair to itself (addresses 0 and 1)
double=add the `A` register to itself (address 0o)
dtcb=change adressing, see manual
dtcf=change adressing, see manual
extend=set extracode flag for next instruction, and the instruction after that, if it is an index.
inhint=disable interrupts
noop=no operation, but note that this is encoded in a context-sensitive fashion
ovsk=skip the next instruction if `A` is overflown
relint=enable interrupts after an inhint
resume=resume program from an ISR
return=return from subroutine, which is to say, move the `Q` register into the `Z` register
tcaa=jump to the address stored in the `A` register
xlq=execute the content of the `A` register, assuming there is a `return` instruction in `L`
xxalq=execute the content of the `L` register as an extracode instruction, assuming there is an `extend` instruction in the `A` register and a `return` instruction in `Q`
zl=zero the `L` register
tc=call a subroutine, can't be nested
ccs=weird compare and jump (10 bit address in erasable memory)
tcf=jump to a memory location (12 bit address in fixed memory)
das=add the `A`, `L` register pair to a memory location
lxch=exchange the `L` register and a memory location
incr=increment a memory location
ads=add the `A` register to a memory location
ca=move a memory location's contents into the `A` register
cs=move a memory location's complement into the `A` register
index=add a memory location to the next instruction before it is executed, without altering memory
dxch=exchange double precision int with `A`, `L` register pair
ts=copy the contents of the `A` register to memory, with extra magic when overflow occured.
xch=exchange an erasable memory location with the `A` register
ad=add a memory location to the `A` register
mask=logical and between the `A` register and a memory location
dcom=bitwise complement of the register pair `A`, `L`
resume=resume program from an ISR
square=square the contents of register `A`
zq=zero the `Q` register
read=read a 9 bit IO channel into register `A`
write=write register `A` into a 9 bit IO channel
rand=read and bitwise and
wand=read and bitwise and with writeback
ror=read and bitwise or
wor=read and bitwise or with writeback
rxor=read and xor
edrupt=noone knows o__O
dv=divide register pair `A`, `L` by a memory location (double precision), putting the quotient/remainder in `A`, `L`, respectively
bzf=branch to a fixed memory location if `A` equals 0
msu=1's complement difference between two 2's complement values, of which the first is the register `A`
qxch=exchange `Q` register with memory location
aug=increment positive and decrement negative values at a memory location, using 1's complement
dim=other way 'round compared to `aug`
dca=move a pair of registers into `A` and `L`
dcs=move the complement of a pair of registers into `A` and `L`
su=subtract a memory location from the `A` register
bzmf=branch to a fixed memory location if `A` is equal or less than 0
mp=multiply two single precision values to form a double precision value, of which one is the accumulator.
